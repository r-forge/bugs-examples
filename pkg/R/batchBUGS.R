batchBUGS <- function(modelFile, data, inits=NULL, cmdTemplate,
                      numChains=1, digits=5,
                      baseDir=getwd(), workName="temp", index= 1,
                      codaStem=FALSE, delWorkFolders=TRUE,
                      stripComments=TRUE, seed=NULL,
                      useWINE = FALSE, WINE = NULL, newWINE = FALSE,
                      WINEPATH = NULL)
{

    if(codaStem && delWorkFolders){
        stop("Work files cannot be deleted when codaStem=TRUE")
    }

    ## Need to get full paths before cd'ing into a temporary directory:
    if (modelFile == basename(modelFile)){
        modelFile <- file.path(baseDir, modelFile)
    }
    if (cmdTemplate == basename(cmdTemplate)){
        cmdTemplate <- file.path(baseDir, cmdTemplate)
    }

    BugsWorkDir <- if(index > 0){
        ## creates a unique directory within the working directory to
        ## hold the input and output of BUGS
        file.path(baseDir, paste(workName, index, 'x',
                                 format(Sys.time(), "%d%H%M%S"),
                                 round(runif(1) * 1000, 0) ,sep=""))
    }
    else{
        file.path(baseDir, workName)
    }

    dir.create(BugsWorkDir, recursive = TRUE, showWarnings=FALSE)
    initDir <- getwd()
    setwd(BugsWorkDir)
    on.exit(setwd(initDir))

    ## writes out the data and inits files into 'BugsWorkDir'
    if (!is.list(data)) {
        if (data == basename(data)) data <- file.path(baseDir, data)
        ## remove comments from the data for OpenBugs 3.03 (and earlier)
        datatxt <- readLines(data,n=-1)
        if (stripComments) datatxt <- gsub('#.*$','',datatxt) #
        writeLines(datatxt,file.path(BugsWorkDir,"data.txt"))

    }
    else {
        bugsData(data, digits=digits)
    }

    if (class(inits)=='character') {
        if (length(inits)!=numChains) stop('Incorrect number of init files.')
        for( i in 1:numChains){
            if(inits[i] == basename(inits[i])) {
                inits[i]<-file.path(baseDir,inits[i])
            }
            initstxt <- readLines(inits[i], n=-1)
            if (stripComments) initstxt <- gsub('#.*$','',initstxt) #
            writeLines(initstxt, file.path(BugsWorkDir,paste("inits",i,sep="")))
        }
    }
    else if(!is.null(inits)) {
        bugsInits(inits=inits,numChains=numChains,digits=digits)
    }

    ## creates the script file
    ## fill in the working directory name
    cmdFileTemplate <- readLines(cmdTemplate, n = -1)
    cmdFileLines <- gsub("\\$TEMPDIR", BugsWorkDir, cmdFileTemplate)
    cmdFileLines <- gsub("\\$TEMPDIR",
                         native2win(BugsWorkDir, useWINE = useWINE,
                                    newWINE = newWINE, WINEPATH = WINEPATH),
                         cmdFileTemplate)
    ## if a seed was specified, replace in cmd script
    if (!missing(seed)){
        cmdFileLines <- gsub("$SEED", seed, cmdFileLines)
    }
    bugsCmdFile <- file.path(BugsWorkDir, "bugsCmds.txt")
    writeLines(cmdFileLines, bugsCmdFile)

    ## remove comments from the model for OpenBugs 3.03 (and earlier)
    modtxt <- readLines(modelFile,n=-1)
    if (stripComments) modtxt <- gsub('#.*$','',readLines(modelFile,n=-1)) #
    writeLines(modtxt,file.path(BugsWorkDir,"model.txt"))

    ## runs BUGS and writes standard output to 'bugsOutput'
    bugsOutput  <- file.path(BugsWorkDir, "bugsOutput.lst")

    bugsExe <- "OpenBUGS"
    if (useWINE || .Platform$OS.type == "windows") {
        ## Need full path
        ob.dir <- getOption("OpenBUGSDir")
        if(is.null(ob.dir)) {
            stop("Cannot use wine: option \"OpenBUGSDir\" not set")
        }
        bugsExe <- file.path(ob.dir, "OpenBUGS")
    }

    if(.Platform$OS.type == "windows" || useWINE){
        bugsCmdFile <- native2win(bugsCmdFile, useWINE = useWINE,
                                  newWINE = newWINE, WINEPATH = WINEPATH)
        cmd <- paste("\"", bugsExe, "\" /PAR \"",
                     bugsCmdFile, "\"", " /HEADLESS", sep = "")
        if (useWINE)
            cmd <- paste(WINE, cmd)
    }
    else {
        cmd <- paste(bugsExe, " < ", bugsCmdFile, " > ", bugsOutput, sep = "")
    }

    ok <- system(cmd) == 0
    if (!ok)
        stop("backBUGS failed to run BUGS command")

    ## extract the information from the output generated by BUGS

    codaCreated<-1
    out.coda <- try( read.openbugs(stem=paste(BugsWorkDir,"/",sep=""),
                                   quiet =TRUE), silent=TRUE)
    if (class(out.coda)=='try-error') {
        codaCreated <- 0
        out.coda <- BugsWorkDir
    }

    if(!codaStem){
        if(codaCreated & delWorkFolders){
            setwd(initDir)
            unlink(BugsWorkDir, recursive=TRUE)
        }
    } else {
        if(codaCreated)out.coda<-paste(BugsWorkDir,"/",sep="")
    }
    return(list(codaCreated=codaCreated, codaOut=out.coda))
}


#############################################################################
### From BRugs :

"bugsData" <-
function(data, fileName = file.path(getwd(), "data.txt"), digits = 5){
  if(is.numeric(unlist(data)))
	write.datafile(lapply(data, formatC, digits = digits, format = "E"), fileName)
  else {
	data.list <- lapply(as.list(data), get, pos = parent.frame(2))
	names(data.list) <- as.list(data)
	write.datafile(lapply(data.list, formatC, digits = digits, format = "E"), fileName)
  }
  invisible(fileName)
}


"bugsInits" <-
function (inits, numChains = 1, fileName, digits = 5){
	if(missing(fileName))
		fileName <- file.path(getwd(), paste("inits", 1:numChains, ".txt", sep = ""))
	if(length(fileName) != numChains)
		stop("numChains = ", numChains, " filenames must be specified")
	if(!is.null(inits)){
	  for (i in 1:numChains){
		if (is.function(inits))
		  write.datafile(lapply(inits(), formatC, digits = digits, format = "E"), fileName[i])
		else
		  write.datafile(lapply(inits[[i]], formatC, digits = digits, format = "E"), fileName[i])
	  }
  }
  invisible(fileName)
}


"write.datafile" <-
function (datalist, towhere, fill = TRUE){
  if (!is.list(datalist) || is.data.frame(datalist))
	  stop("First argument to write.datafile must be a list.")
  cat(formatdata(datalist), file = towhere, fill = fill)
}

"formatdata" <-
function (datalist){
	if (!is.list(datalist) || is.data.frame(datalist))
		stop("argument to formatdata() ", "must be a list")
	n <- length(datalist)
	datalist.string <- vector(n, mode = "list")
	for (i in 1:n) {
		if (length(datalist[[i]]) == 1)
			datalist.string[[i]] <- paste(names(datalist)[i],
				"=", as.character(datalist[[i]]), sep = "")
		if (is.vector(datalist[[i]]) && length(datalist[[i]]) > 1)
			datalist.string[[i]] <- paste(names(datalist)[i],
				"=c(", paste(as.character(datalist[[i]]), collapse = ", "),
				")", sep = "")
		if (is.array(datalist[[i]]))
			datalist.string[[i]] <- paste(names(datalist)[i],
				"= structure(.Data= c(", paste(as.character(as.vector(aperm(datalist[[i]]))),
				  collapse = ", "), "), .Dim=c(", paste(as.character(dim(datalist[[i]])),
				  collapse = ", "), "))", sep = "")
	}
	datalist.tofile <- paste("list(", paste(unlist(datalist.string),
		collapse = ", "), ")", sep = "")
	return(datalist.tofile)
}


### From BRugs
#############################################################################
# from R2WinBUGS

## get drive mapping table from ~/.wine/config
winedriveMap <- function(config="~/.wine/config") {
  if (!file.exists(config)) return (NULL);
  con <- readLines(config)
  con <- con[- grep("^;", con)]
  drive <- con[grep("^\\[Drive ", con)]
  drive <- substr(drive, 8, 8)
  drive <- paste(drive, ":", sep="")
  path <- con[grep("Path", con)]
  len <- length(drive)
  path <- path[1:len]
  dir <- sapply(path,
                 function(x) {
                   foo <- unlist(strsplit(x, "\""))
                   foo[length(foo)]
                 })
  dir <- sub("%HOME%",tools::file_path_as_absolute("~"),dir)
  data.frame(drive = I(drive), path = I(dir), row.names=NULL)
}

## translate windows dir to native dir
winedriveTr <- function(windir, DriveTable=winedriveMap()) {
  win.dr <- substr(windir, 1, 2)
  ind <- pmatch(toupper(win.dr), DriveTable$drive)
  native.dr <- DriveTable$path[ind]
  sub(win.dr, native.dr, windir)
}

## translate full Unix path to Wine path
winedriveRTr <- function(unixpath, DriveTable=winedriveMap()) {
  blocks <- strsplit(unixpath,"/")[[1]]
  cblocks <- c("/",sapply(1+seq(along=blocks[-1]),
                    function(n) paste(blocks[1:n],collapse="/")))
  path <- match(cblocks,DriveTable$path)
  if (any(!is.na(path))) {
    unixdir <- cblocks[which.min(path)]
    windrive <- paste(DriveTable$drive[min(path,na.rm=TRUE)],"/",sep="")
    winpath <- sub("//","/",sub(unixdir,windrive,unixpath)) ## kluge
  } else stop("can't find equivalent Windows path: file may be inaccessible")
  winpath
}


win2native <- function(x, useWINE=.Platform$OS.type != "windows") { # win -> native
  if (useWINE) winedriveTr(x)
  else x
}


native2win <- function(x, useWINE=.Platform$OS.type != "windows", newWINE=TRUE, WINEPATH=NULL) { # native -> win
  if(is.R()){
      if (useWINE && !newWINE) return(winedriveRTr(x))
      if (useWINE && newWINE) {
          x <- system(paste(WINEPATH, "-w", x), intern = TRUE)
          return(gsub("\\\\", "/", x)) ## under wine BUGS cannot use \ or \\
      } else x
  } else { #S-PLUS
      gsub("\\\\", "/", x)
  }
}

